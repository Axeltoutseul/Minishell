/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   adv_redirection.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: quenalla <quenalla@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/17 02:39:20 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/11 16:50:53 by quenalla         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	get_redirection_flags_mode(const char *op, int *flags, int *mode)
{
	if (ft_strcmp(op, ">") == 0)
	{
		*flags = O_WRONLY | O_CREAT | O_TRUNC;
		*mode = 0644;
		return (1);
	}
	if (ft_strcmp(op, ">>") == 0)
	{
		*flags = O_WRONLY | O_CREAT | O_APPEND;
		*mode = 0644;
		return (1);
	}
	if (ft_strcmp(op, "<") == 0)
	{
		*flags = O_RDONLY;
		*mode = 0;
		return (1);
	}
	return (0);
}

int	adv_handle_redirect(const char *target, const char *op, int std_fd)
{
	int	flags;
	int	mode;
	int	ret;
	int	fd;

	if (get_redirection_flags_mode(op, &flags, &mode))
	{
		ret = redirect_file(target, std_fd, flags, mode);
		return (ret);
	}
	if (ft_strcmp(op, ">&") == 0)
	{
		fd = ft_atoi(target);
		if (dup2(fd, std_fd) == -1)
		{
			perror("dup2");
			return (-1);
		}
		return (0);
	}
	return (-1);
}

int	handle_redirection_char(const char *file, const char *op)
{
	int	std_fd;

	if (ft_strcmp(op, "<") == 0)
		std_fd = STDIN_FILENO;
	else
		std_fd = STDOUT_FILENO;
	return (adv_handle_redirect(file, op, std_fd));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   adv_tokeniser1.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: quenalla <quenalla@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/17 03:00:00 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/08 11:27:54 by quenalla         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*append_char(char *str, char c)
{
	int		i;
	int		len;
	char	*new_str;

	if (str)
		len = ft_strlen(str);
	else
		len = 0;
	new_str = malloc(len + 2);
	if (!new_str)
		return (NULL);
	i = 0;
	while (str && str[i])
	{
		new_str[i] = str[i];
		i = i + 1;
	}
	new_str[i] = c;
	new_str[i + 1] = '\0';
	if (str)
		free(str);
	return (new_str);
}

void	process_default(char c, t_state *state, char **curr)
{
	if (c == ' ' || c == '\t')
		return ;
	if (c == '\'')
	{
		*state = STATE_IN_SINGLE;
		return ;
	}
	if (c == '"')
	{
		*state = STATE_IN_DOUBLE;
		return ;
	}
	if (c == '\\')
	{
		*state = STATE_ESCAPING;
		return ;
	}
	*curr = append_char(*curr, c);
}

void	process_in_single(char c, t_state *state, char **curr)
{
	if (c == '\'')
		*state = STATE_DEFAULT;
	else
		*curr = append_char(*curr, c);
}

void	process_in_double(char c, t_state *state, char **curr)
{
	if (c == '"')
		*state = STATE_DEFAULT;
	else if (c == '\\')
		*state = STATE_ESCAPING;
	else
		*curr = append_char(*curr, c);
}

void	process_escaping(char c, t_state *state, char **curr)
{
	*curr = append_char(*curr, c);
	*state = STATE_DEFAULT;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   adv_tokeniser2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 13:15:42 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 12:43:52 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	process_char(char c, t_state *state, char **curr)
{
	if (*state == STATE_DEFAULT)
	{
		process_default(c, state, curr);
		return ;
	}
	if (*state == STATE_IN_SINGLE)
	{
		process_in_single(c, state, curr);
		return ;
	}
	if (*state == STATE_IN_DOUBLE)
	{
		process_in_double(c, state, curr);
		return ;
	}
	if (*state == STATE_ESCAPING)
	{
		process_escaping(c, state, curr);
		return ;
	}
}

void	tokenize_loop(const char *line, t_tokenize_context *ctx)
{
	while (line[ctx->i] != '\0')
	{
		process_char(line[ctx->i], &ctx->state, &ctx->curr);
		if (ctx->state == STATE_DEFAULT
			&& (line[ctx->i] == ' ' || line[ctx->i] == '\t'))
		{
			if (ctx->curr)
			{
				ctx->tokens[ctx->ti] = ctx->curr;
				ctx->ti = ctx->ti + 1;
				ctx->curr = NULL;
			}
		}
		ctx->i = ctx->i + 1;
	}
}

char	*preprocess_line(const char *line)
{
	int		i;
	int		j;
	int		len;
	char	*new_line;

	i = 0;
	j = 0;
	len = ft_strlen(line);
	new_line = malloc(sizeof(char) * (len * 3 + 1));
	if (!new_line)
		return (NULL);
	while (line[i])
	{
		if (line[i] == '>' || line[i] == '<')
		{
			handle_redirection(line, &i, &j, new_line);
		}
		else
			new_line[j++] = line[i];
		i = i + 1;
	}
	new_line[j] = '\0';
	return (new_line);
}

char	**advanced_tokenize_modified(const char *line)
{
	char	*preprocessed;
	char	**tokens;

	preprocessed = preprocess_line(line);
	if (!preprocessed)
		return (NULL);
	tokens = advanced_tokenize(preprocessed);
	free(preprocessed);
	return (tokens);
}

char	**advanced_tokenize(const char *line)
{
	t_tokenize_context	ctx;

	ctx.i = 0;
	ctx.ti = 0;
	ctx.curr = NULL;
	ctx.state = STATE_DEFAULT;
	ctx.tokens = malloc(sizeof(char *) * (ft_strlen(line) + 1));
	if (!ctx.tokens)
		return (NULL);
	tokenize_loop(line, &ctx);
	if (ctx.curr)
	{
		ctx.tokens[ctx.ti] = ctx.curr;
		ctx.ti = ctx.ti + 1;
	}
	ctx.tokens[ctx.ti] = NULL;
	return (ctx.tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   adv_tokeniser3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 12:42:20 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 12:47:09 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_redirection(const char *line, int *i, int *j, char *nw_lin)
{
	if (*i > 0 && line[*i - 1] != ' ')
		nw_lin[(*j)++] = ' ';
	nw_lin[(*j)++] = line[*i];
	if (line[*i + 1] && line[*i + 1] == line[*i])
	{
		*i = *i + 1;
		nw_lin[(*j)++] = line[*i];
	}
	if (line[*i + 1] && line[*i + 1] != ' ')
		nw_lin[(*j)++] = ' ';
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   build_new_tokens.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 13:51:41 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 18:22:48 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_token_build_new_tokens(t_build_ctx *ctx)
{
	char	*temp;
	t_redir	*new_redir;

	temp = ft_strtrim(ctx->tokens[ctx->i], "\t");
	if (!temp)
		return (-1);
	if (ft_strcmp(temp, ">") == 0 || ft_strcmp(temp, ">>") == 0
		|| ft_strcmp(temp, "<") == 0)
	{
		free(temp);
		if (!ctx->tokens[ctx->i + 1])
			return (-1);
		new_redir = create_redirection_token(ctx->tokens, &ctx->i);
		if (!new_redir)
			return (-1);
		new_redir->next = *(ctx->redir);
		*(ctx->redir) = new_redir;
		return (0);
	}
	ctx->new_tokens[ctx->j] = ft_strdup(temp);
	free(temp);
	ctx->j++;
	ctx->i++;
	return (0);
}

char	**build_new_tokens(char **tokens, t_redir **redir, int size)
{
	t_build_ctx	ctx;
	char		**new_tokens;

	new_tokens = malloc(sizeof(char *) * (size + 1));
	if (!new_tokens)
		return (NULL);
	ctx.tokens = tokens;
	ctx.i = 0;
	ctx.j = 0;
	ctx.new_tokens = new_tokens;
	ctx.redir = redir;
	while (tokens[ctx.i])
	{
		if (handle_token_build_new_tokens(&ctx) == -1)
		{
			free_2d_array(new_tokens);
			return (NULL);
		}
	}
	new_tokens[ctx.j] = NULL;
	return (new_tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_words.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 12:43:49 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/27 18:23:40 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	check_path_validity(char *cmd)
{
	if (access(cmd, F_OK | X_OK) == -1 || !ft_strlen(ft_strrchr(cmd, '/') + 1))
		return (0);
	return (1);
}

int	existing_command(char **paths, char *cmd)
{
	int		i;
	int		result;
	char	*cmd_path;

	i = 0;
	if (!cmd)
		return (0);
	if (ft_strchr(cmd, '/'))
		return (check_path_validity(cmd));
	while (paths[i])
	{
		cmd_path = ft_strjoin(paths[i], cmd);
		if (!cmd_path)
			return (0);
		result = access(cmd_path, F_OK | X_OK);
		free(cmd_path);
		if (result == 0)
			return (1);
		i++;
	}
	return (0);
}

void	check_error(char *name, char *arg)
{
	int		i;
	char	*val;

	i = 0;
	if (count_occurs(arg, '='))
		val = ft_strchr(arg, '=') + 1;
	else
		val = NULL;
	while (name[i] && name[i] != '&' && name[i] != '(' && name[i] != ')')
		i++;
	if (val && !valid_value(val))
		ft_printf("syntax error: unclosed quote\n");
	else if (name[i] == '&' || name[i] == '(' || name[i] == ')')
		ft_printf("minishell: syntax error near unexpected token '%c'\n",
			name[i]);
	else
		ft_printf("export: not valid in this context: '%s'\n", name);
}

int	is_space(int c)
{
	if (c == ' ' || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

int	invalid_prompt(char	*line)
{
	int	i;
	int	j;

	i = 0;
	j = ft_strlen(line) - 1;
	if (line[i] == '|' || line[j] == '|')
		return (2);
	while (line[i])
	{
		if (ft_strlen(line + i) >= 2 && line[i] == '|' && line[i + 1] == '|')
			return (2);
		if (ft_strlen(line + i) >= 2
			&& ((line[i] == '<' && line[i + 1] == '>')
				|| (line[i] == '>' && line[i + 1] == '<')))
			return (1);
		if (ft_strlen(line + i) >= 3)
		{
			if ((line[i] == '<' || line[i] == '>')
				&& (line[i + 1] == '<' || line[i + 1] == '>')
				&& (line[i + 2] == '<' || line[i + 2] == '>'))
				return (1);
		}
		i++;
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_echo.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/06 18:05:39 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/31 16:36:23 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	exec_echo(t_prompt *prompt)
{
	int	i;
	int	newline;

	i = 1;
	newline = 1;
	while (prompt->strs[i] && is_valid_n_option(prompt->strs[i]))
	{
		newline = 0;
		i++;
	}
	while (prompt->strs[i])
	{
		ft_printf("%s", prompt->strs[i]);
		if (prompt->strs[i + 1])
			ft_printf(" ");
		i++;
	}
	if (newline)
		ft_printf("\n");
}

void	exec_echo_builtin(t_command *cmd)
{
	int	i;
	int	newline;

	i = 1;
	newline = 1;
	while (cmd->args[i] && is_valid_n_option(cmd->args[i]))
	{
		newline = 0;
		i++;
	}
	while (cmd->args[i])
	{
		ft_printf("%s", cmd->args[i]);
		if (cmd->args[i + 1])
			ft_printf(" ");
		i++;
	}
	if (newline)
		ft_printf("\n");
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_export.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 17:44:58 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 15:56:10 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	exec_export(t_shell *shell, t_prompt *prompt)
{
	if (count_words(prompt->cmd_line) == 1)
		write_export(shell->export_lines);
	else
		add_lines(shell, prompt);
	free_2d_array(shell->env);
	shell->env = get_env_lines(shell->env_lines);
}

void	add_to_env_and_export(t_env *new, t_env *temp, t_shell *shell)
{
	add_env_line(&shell->env_lines, new);
	add_env_line(&shell->export_lines, temp);
}

void	add_lines(t_shell *shell, t_prompt *prompt)
{
	t_env	*new;
	t_env	*temp;
	int		i;

	i = 1;
	while (i < count_strings(prompt->strs))
	{
		new = new_line(prompt->strs[i]);
		temp = new_line(prompt->strs[i]);
		if (!valid_arg(new->name, prompt->strs[i]))
		{
			check_error(new->name, prompt->strs[i]);
			free_new_and_temp(new, temp);
			break ;
		}
		else if (!is_in_list(shell->export_lines, new->name))
			add_to_env_and_export(new, temp, shell);
		else if (ft_strchr(prompt->strs[i], '='))
		{
			update_line(prompt->strs[i], &shell->env_lines);
			update_line(prompt->strs[i], &shell->export_lines);
			free_new_and_temp(new, temp);
		}
		i++;
	}
}

int	is_in_list(t_env *env, char *var_name)
{
	t_env	*temp;

	temp = env;
	while (temp)
	{
		if (ft_strcmp(var_name, temp->name) == 0)
			return (1);
		temp = temp->next;
	}
	return (0);
}

void	update_line(char *arg, t_env **env)
{
	t_env	*temp;
	int		i;
	char	*var_name;
	char	*value;

	temp = *env;
	i = 0;
	while (arg[i] && arg[i] != '=')
		i++;
	var_name = ft_strndup(arg, i);
	value = ft_strdup(ft_strchr(arg, '=') + 1);
	while (temp)
	{
		if (ft_strcmp(var_name, temp->name) == 0)
		{
			free(temp->value);
			free(temp->line);
			temp->value = value;
			temp->line = ft_strjoin(temp->name, "=");
			temp->line = join_and_free(temp->line, temp->value);
		}
		temp = temp->next;
	}
	free(var_name);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_unset.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:39:27 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 13:56:58 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	exec_unset(t_shell *shell, t_prompt *prompt)
{
	int	i;

	i = 1;
	if (prompt->nb_args == 1)
		ft_printf("unset: not enough arguments\n");
	else
	{
		while (prompt->strs[i])
		{
			if (!valid_name(prompt->strs[i]))
			{
				ft_printf("unset: %s: invalid parameter name\n",
					prompt->strs[i]);
				break ;
			}
			if (ft_strcmp(prompt->strs[i], "_") != 0)
			{
				remove_line(&shell->env_lines, prompt->strs[i]);
				remove_line(&shell->export_lines, prompt->strs[i]);
			}
			i++;
		}
		free_2d_array(shell->env);
		shell->env = get_env_lines(shell->env_lines);
	}
}

void	del_content(t_env *temp)
{
	free(temp->name);
	free(temp->value);
	free(temp->line);
	free(temp);
}

void	remove_line(t_env **lst, char *arg)
{
	t_env	*next_one;
	t_env	*temp;

	temp = *lst;
	if (ft_strcmp(temp->name, arg) == 0)
	{
		*lst = temp->next;
		del_content(temp);
		return ;
	}
	while (temp)
	{
		if (temp->next && ft_strcmp(temp->next->name, arg) == 0)
		{
			next_one = temp->next;
			temp->next = temp->next->next;
			del_content(next_one);
			return ;
		}
		temp = temp->next;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_terminal.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/13 18:06:58 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 13:20:08 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_2d_array(char **strs)
{
	int	i;

	i = 0;
	if (!strs)
		return ;
	while (strs[i])
		free(strs[i++]);
	free(strs);
}

void	free_prompt(t_prompt *prompt)
{
	if (prompt)
	{
		free(prompt->cmd_line);
		free_2d_array(prompt->strs);
		free(prompt);
	}
}

void	free_terminal(t_shell *shell)
{
	free(shell->path);
	free(shell->home_path);
	free(shell->pwd);
	free(shell->old_pwd);
	free_2d_array(shell->env);
	free_2d_array(shell->splitted_path);
	free_env_lines(shell->env_lines);
	free_env_lines(shell->export_lines);
	ft_lstclear(&shell->history, &free);
	rl_clear_history();
	free(shell);
}

void	free_new_and_temp(t_env *new, t_env *temp)
{
	del_content(new);
	del_content(temp);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_env_paths.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/12 19:49:59 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 19:07:47 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_path_value(char **envp, char *name)
{
	int		i;
	int		size;
	char	*path;

	i = 0;
	size = ft_strlen(name) + 1;
	while (envp[i] && ft_strncmp(envp[i], name, size - 1) != 0)
	{
		i = i + 1;
	}
	if (!envp[i] || (envp[i] && !ft_strchr(envp[i], '=')))
		return (NULL);
	path = ft_strdup(envp[i] + size);
	return (path);
}

int	get_shell_level(char **envp)
{
	int		i;
	int		shlvl;

	i = 0;
	if (!envp[0])
		return (-1);
	while (ft_strncmp(envp[i], "SHLVL=", 6) != 0)
	{
		i = i + 1;
	}
	shlvl = ft_atoi(envp[i] + 6);
	return (shlvl);
}

char	**split_path(char *env_line)
{
	int		i;
	char	**splitted_path;

	i = 0;
	if (!env_line)
		return (NULL);
	splitted_path = ft_split(env_line, ':');
	i = 0;
	while (splitted_path[i])
	{
		splitted_path[i] = join_and_free(splitted_path[i], "/");
		i = i + 1;
	}
	return (splitted_path);
}

char	*get_command_path(char *cmd, char **env)
{
	char	**paths;
	char	*path_line;
	char	*full_path;

	if (ft_strchr(cmd, '/') != NULL)
	{
		return (ft_strdup(cmd));
	}
	path_line = get_path_value(env, "PATH");
	paths = split_path(path_line);
	if (paths == 0)
	{
		return (0);
	}
	full_path = search_cmd_in_paths(paths, cmd);
	free_2d_array(paths);
	return (full_path);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_env_paths2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 10:22:47 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 11:21:14 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_env_value(char **env, char *key)
{
	int		i;
	int		key_len;

	i = 0;
	key_len = ft_strlen(key);
	while (env[i])
	{
		if (ft_strncmp(env[i], key, key_len) == 0)
		{
			return (env[i] + key_len);
		}
		i = i + 1;
	}
	return (0);
}

char	*search_cmd_in_paths(char **paths, char *cmd)
{
	int		i;
	char	*temp;
	char	*full_path;

	i = 0;
	full_path = 0;
	while (paths[i])
	{
		temp = ft_strjoin(paths[i], cmd);
		if (access(temp, F_OK | X_OK) == 0)
		{
			full_path = temp;
			return (full_path);
		}
		free(temp);
		i = i + 1;
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   getpid_setenv.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: quenalla <quenalla@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 15:23:14 by quenalla          #+#    #+#             */
/*   Updated: 2025/03/28 15:41:13 by quenalla         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	contains_redirection(char **tokens)
{
	int	i;

	i = 0;
	while (tokens[i])
	{
		if (!ft_strcmp(tokens[i], ">")
			|| !ft_strcmp(tokens[i], ">>")
			|| !ft_strcmp(tokens[i], "<")
			|| !ft_strcmp(tokens[i], "<<"))
			return (1);
		i++;
	}
	return (0);
}

pid_t	my_getpid(void)
{
	int		fd;
	char	buf[64];
	ssize_t	n;

	fd = open("/proc/self/stat", O_RDONLY);
	if (fd < 0)
		return (-1);
	n = read(fd, buf, sizeof(buf) - 1);
	close(fd);
	if (n <= 0)
		return (-1);
	buf[n] = '\0';
	return ((pid_t)ft_atoi(buf));
}

static t_env	*create_env_node(const char *name, const char *value)
{
	t_env	*node;

	node = malloc(sizeof(t_env));
	if (!node)
		return (NULL);
	node->name = ft_strdup(name);
	node->value = ft_strdup(value);
	node->next = NULL;
	return (node);
}

int	my_setenv(t_env **env, const char *name, const char *value, int overwrite)
{
	t_env	*curr;

	if (!name || !value)
		return (-1);
	curr = *env;
	while (curr)
	{
		if (!ft_strcmp(curr->name, name))
		{
			if (overwrite)
			{
				free(curr->value);
				curr->value = ft_strdup(value);
			}
			return (0);
		}
		curr = curr->next;
	}
	curr = create_env_node(name, value);
	if (!curr)
		return (-1);
	curr->next = *env;
	*env = curr;
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_dollar.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 14:36:56 by quenalla          #+#    #+#             */
/*   Updated: 2025/04/01 00:09:50 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*append_str(char *dest, const char *src)
{
	size_t	size;
	size_t	i;
	size_t	j;
	char	*new_str;

	size = ft_strlen(dest) + ft_strlen(src);
	new_str = malloc(size + 1);
	if (new_str == NULL)
		return (NULL);
	i = 0;
	j = 0;
	while (dest && dest[i])
	{
		new_str[i] = dest[i];
		i = i + 1;
	}
	while (src[j])
	{
		new_str[i + j] = src[j];
		j = j + 1;
	}
	new_str[i + j] = '\0';
	if (dest)
		free(dest);
	return (new_str);
}

char	*expand_variables(const char *input, char **env)
{
	int		i;
	char	*result;

	i = 0;
	result = ft_strdup("");
	if (result == NULL)
		return (NULL);
	return (do_expand_loop(input, &i, result, env));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_dollar2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 12:53:33 by qacjl             #+#    #+#             */
/*   Updated: 2025/04/01 00:11:47 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*expand_special_var(const char *in, int *i)
{
	t_shell	*shell;

	shell = get_shell_instance();
	if (in[*i + 1] == '?')
	{
		*i = *i + 2;
		return (ft_itoa(shell->exit_status));
	}
	if (in[*i + 1] == '$')
	{
		*i = *i + 2;
		return (ft_itoa(getpid()));
	}
	return (NULL);
}

char	*expand_var(const char *in, int *i, char **env)
{
	int		j;
	char	*name;
	char	*val;
	char	*special;

	special = expand_special_var(in, i);
	if (special != NULL)
		return (special);
	j = *i + 1;
	while (in[j] && (ft_isalnum(in[j]) || in[j] == '_'))
		j = j + 1;
	if (j == *i + 1)
	{
		*i = *i + 1;
		return (ft_strdup("$"));
	}
	name = ft_strndup(in + *i + 1, j - *i - 1);
	*i = j;
	val = get_path_value(env, name);
	if (val == NULL)
		val = ft_strdup("");
	free(name);
	return (val);
}

void	check_state(int i, int *state, const char *input)
{
	if (input[i] == '\'' && *state == 0)
		*state = 1;
	else if (input[i] == '\'' && *state == 1)
		*state = 0;
	else if (input[i] == '"' && *state == 0)
		*state = 2;
	else if (input[i] == '"' && *state == 2)
		*state = 0;
}

char	*handle_dollar_case(const char *input, int *i, char **env)
{
	char	*temp;

	if (input[*i + 1] == '?' || input[*i + 1] == '$')
	{
		temp = expand_var(input, i, env);
		return (temp);
	}
	if (!input[*i + 1] || (!ft_isalnum(input[*i + 1]) && input[*i + 1] != '_'))
	{
		*i = *i + 1;
		return (ft_strdup("$"));
	}
	temp = expand_var(input, i, env);
	return (temp);
}

char	*do_expand_loop(const char *input, int *i, char *result, char **env)
{
	char	*temp;
	char	ch[2];
	int		state;

	state = 0;
	while (input[*i])
	{
		if (input[*i] == '$' && state != 1)
		{
			temp = handle_dollar_case(input, i, env);
			result = append_str(result, temp);
			free(temp);
			continue ;
		}
		check_state(*i, &state, input);
		ch[0] = input[*i];
		ch[1] = '\0';
		result = append_str(result, ch);
		*i = *i + 1;
	}
	return (result);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_paths.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/04 18:07:10 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 21:31:00 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	update_vars(t_shell *shell)
{
	free_2d_array(shell->env);
	shell->env = get_env_lines(shell->env_lines);
	if (shell->old_pwd)
	{
		free(shell->old_pwd);
		shell->old_pwd = get_path_value(shell->env, "OLDPWD");
	}
	free(shell->path);
	free(shell->home_path);
	free(shell->pwd);
	free_2d_array(shell->splitted_path);
	shell->path = get_path_value(shell->env, "PATH");
	shell->home_path = get_path_value(shell->env, "HOME");
	shell->pwd = get_path_value(shell->env, "PWD");
	shell->splitted_path = split_path(shell->path);
}

static void	check_home_path(t_shell *shell)
{
	if (shell->home_path == NULL)
		ft_printf("bash: cd : HOME not set\n");
	else
	{
		if (chdir(shell->home_path) != 0)
			ft_printf("cd: no such file or directory: %s\n", shell->home_path);
		else if (shell->old_pwd && ft_strcmp(shell->old_pwd, shell->pwd) != 0)
		{
			free(shell->old_pwd);
			shell->old_pwd = ft_strdup(shell->pwd);
		}
	}
}

void	exec_cd(t_shell *shell, t_prompt *prompt)
{
	char	buffer[PATH_MAX];

	if (prompt->nb_args == 2 && chdir(prompt->strs[1]) != 0)
		ft_printf("cd: no such file or directory: %s\n", prompt->strs[1]);
	else if (prompt->nb_args > 2)
		ft_printf("cd: string not in pwd: %s\n", prompt->strs[1]);
	else
	{
		if (prompt->nb_args == 1)
			check_home_path(shell);
		else if (shell->old_pwd && ft_strcmp(shell->old_pwd, shell->pwd) != 0)
		{
			free(shell->old_pwd);
			shell->old_pwd = ft_strdup(shell->pwd);
		}
		getcwd(buffer, PATH_MAX);
		free(shell->pwd);
		shell->pwd = ft_strdup(buffer);
	}
	update_paths(shell, &shell->env_lines);
	update_paths(shell, &shell->export_lines);
}

void	update_paths(t_shell *shell, t_env **env)
{
	t_env	*temp;

	temp = *env;
	while (temp)
	{
		if (ft_strcmp(temp->name, "OLDPWD") == 0)
		{
			free(temp->value);
			temp->value = ft_strdup(shell->old_pwd);
			free(temp->line);
			temp->line = ft_strjoin("OLDPWD", "=");
			temp->line = join_and_free(temp->line, shell->old_pwd);
		}
		else if (ft_strcmp(temp->name, "PWD") == 0)
		{
			free(temp->value);
			temp->value = ft_strdup(shell->pwd);
			free(temp->line);
			temp->line = ft_strjoin("PWD", "=");
			temp->line = join_and_free(temp->line, shell->pwd);
		}
		temp = temp->next;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_strings.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 15:55:41 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 20:53:30 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_swap(char **s1, char **s2)
{
	char	*tmp;

	tmp = *s1;
	*s1 = *s2;
	*s2 = tmp;
}

int	is_valid_n_option(const char *str)
{
	int	i;

	if (str == NULL || str[0] != '-')
		return (0);
	i = 1;
	if (str[i] == '\0')
		return (0);
	while (str[i])
	{
		if (str[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

void	sort_strings(char **envp, int size)
{
	int		i;
	char	*tmp;

	i = 0;
	while (i < size - 1)
	{
		if (ft_strcmp(envp[i], envp[i + 1]) > 0)
		{
			tmp = envp[i];
			envp[i] = envp[i + 1];
			envp[i + 1] = tmp;
			i = 0;
		}
		else
			i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: quenalla <quenalla@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/17 03:04:07 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/25 14:47:10 by quenalla         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_heredoc_parent_pipe(const char *delimiter)
{
	int		pipe_fd[2];
	char	*line;

	if (pipe(pipe_fd) == -1)
	{
		perror("pipe");
		return (-1);
	}
	while (1)
	{
		line = readline("heredoc> ");
		if (!line)
			break ;
		if (strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		write(pipe_fd[1], line, strlen(line));
		write(pipe_fd[1], "\n", 1);
		free(line);
	}
	close(pipe_fd[1]);
	return (pipe_fd[0]);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   history.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/11 14:44:05 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/24 11:57:47 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	update_history(t_shell *shell, const char *line)
{
	t_list	*new_node;

	new_node = ft_lstnew(ft_strdup(line));
	if (new_node == NULL)
		return ;
	ft_lstadd_back(&shell->history, new_node);
	add_history(line);
}

void	display_history(t_shell *shell)
{
	t_list	*temp;
	int		i;

	i = 0;
	temp = shell->history;
	while (temp)
	{
		ft_printf("%d  %s\n", i + 1, (char *)temp->content);
		i = i + 1;
		temp = temp->next;
	}
}

void	verif_history(t_shell *shell, const char *input)
{
	if (input[0] != '\0')
		update_history(shell, input);
	if (ft_strcmp(input, "history") == 0)
		display_history(shell);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/26 20:28:15 by axbaudri          #+#    #+#             */
/*   Updated: 2025/04/01 00:12:19 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	check_cmd(t_pipeline *pipeline)
{
	int	i;

	i = 0;
	while (i < pipeline->count)
	{
		if (pipeline->commands[i].heredoc_delim)
		{
			pipeline->commands[i].heredoc_fd = handle_heredoc_parent_pipe
				(pipeline->commands[i].heredoc_delim);
			if (pipeline->commands[i].heredoc_fd == -1)
				return (free_pipeline(pipeline));
			free(pipeline->commands[i].heredoc_delim);
			pipeline->commands[i].heredoc_delim = NULL;
		}
		i++;
	}
}

void	exec_command2(t_pipeline *pipeline, t_shell *shell, char **env)
{
	check_cmd(pipeline);
	signal(SIGINT, SIG_IGN);
	execute_pipeline(shell, pipeline, env);
	signal(SIGINT, handle_sigint);
	free_pipeline(pipeline);
}

void	exec_command(t_shell *shell, t_prompt *prompt, char **env, char *line)
{
	char		*tmp;
	t_pipeline	*pipeline;

	if (!count_strings(prompt->strs) || !closed_quotes(line))
		return ;
	tmp = get_line_without_space(line);
	if (invalid_prompt(tmp))
	{
		if (invalid_prompt(tmp) == 2)
			ft_printf("bash: syntax error near unexpected token `|'\n");
		else
			ft_printf("bash: syntax error near unexpected token `newline'\n");
		return (free(tmp));
	}
	free(tmp);
	if (!ft_strchr(line, '|') && is_builtin(prompt->strs[0])
		&& !contains_redirection(prompt->strs))
		return (execute_builtin(shell, prompt));
	pipeline = parse_input(line, shell->env);
	if (pipeline == NULL)
		return ;
	exec_command2(pipeline, shell, env);
}

static int	process_input(t_shell *shell, char **env)
{
	char	*line;
	t_prompt	*prompt;

	line = readline("\001\033[0;32m\002minishell> \001\033[0m\002");
	if (line == NULL)
	{
		write(1, "exit\n", 5);
		shell->exit_status = 1;
		return (-1);
	}
	verif_history(shell, line);
	prompt = init_prompt(line, shell->env);
	exec_command(shell, prompt, env, line);
	update_vars(shell);
	free_prompt(prompt);
	free(line);
	return (0);
}


int	main(int argc, char **argv, char **env)
{
	t_shell		*shell;

	(void)argc;
	(void)argv;
	shell = init_shell(env);
	set_shell_instance(shell);
	check_signal(&shell->shlvl);
	while (process_input(shell, env) != -1)
		;
	free_terminal(shell);
	return (shell->exit_status);
}

/*int	main(int argc, char **argv, char **env)
{
	t_shell		*shell;
	char		*line;
	t_prompt	*prompt;

	(void)argc;
	(void)argv;
	shell = init_shell(env);
	set_shell_instance(shell);
	check_signal(&shell->shlvl);
	while (1)
	{
		line = readline("\001\033[0;32m\002minishell> \001\033[0m\002");
		if (line == NULL)
		{
			write(1, "exit\n", 5);
			shell->exit_status = 1;
			break ;
		}
		verif_history(shell, line);
		prompt = init_prompt(line, shell->env);
		exec_command(shell, prompt, env, line);
		update_vars(shell);
		free_prompt(prompt);
		free(line);
	}
	free_terminal(shell);
	return (shell->exit_status);
}*/

# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/12/12 13:47:59 by axbaudri          #+#    #+#              #
#    Updated: 2025/03/31 16:42:18 by qacjl            ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

CC = cc

CFLAGS = -Wall -Wextra -Werror -g

NAME = minishell

RM = rm -f

SRCS =	adv_redirection.c \
		adv_tokeniser1.c \
		adv_tokeniser2.c \
		adv_tokeniser3.c \
		build_new_tokens.c \
		check_words.c \
		exec_echo.c \
		exec_export.c \
		exec_unset.c \
		free_terminal.c \
		get_env_paths.c \
		get_env_paths2.c \
		getpid_setenv.c \
		handle_dollar.c \
		handle_dollar2.c \
		handle_paths.c \
		handle_strings.c \
		heredoc.c \
		history.c \
		main.c \
		manage_env_list.c \
		minishell.c \
		new_terminal.c \
		parse_prompt.c \
		parser1.c \
		parser2.c \
		parser3.c \
		pipe_handling.c \
		pipeline.c \
		pipeline2.c \
		pipeline3.c \
		read_content.c \
		redirect_file.c \
		redirect_file2.c \
		shell_instance.c \
		signal.c \
		split_pipeline.c \
		string_utils.c \
		write_content.c

OBJS = $(SRCS:.c=.o)

LIBFT = libft/libft.a

$(NAME): $(OBJS) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS) -o $(NAME) libft/libft.a -lreadline

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

$(LIBFT):
	make -C libft/

all: $(NAME)

clean:
	$(RM) $(OBJS)
	make clean -C libft/

fclean: clean
	$(RM) $(NAME)

re: fclean all

.PHONY: all clean fclean re

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   manage_env_list.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 14:16:06 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 13:21:01 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_env	*new_line(char *env_line)
{
	t_env	*new_node;
	int		i;

	new_node = (t_env *)malloc(sizeof(t_env));
	i = 0;
	if (!new_node)
		return (NULL);
	while (env_line[i] && env_line[i] != '=')
		i++;
	new_node->name = ft_strndup(env_line, i);
	if (ft_strchr(env_line, '='))
	{
		if (env_line[i + 1] == '\'')
			new_node->value = ft_strtrim(ft_strchr(env_line, '=') + 1, "'");
		else
			new_node->value = ft_strtrim(ft_strchr(env_line, '=') + 1, "\"");
	}
	else
		new_node->value = NULL;
	new_node->line = ft_strdup(env_line);
	new_node->next = NULL;
	return (new_node);
}

int	env_size(t_env *env)
{
	int	i;

	i = 0;
	while (env)
	{
		env = env->next;
		i = i + 1;
	}
	return (i);
}

void	add_env_line(t_env **env, t_env *new)
{
	t_env	*temp;

	temp = *env;
	if (*env == NULL)
	{
		*env = new;
		return ;
	}
	while (temp->next != NULL)
		temp = temp->next;
	temp->next = new;
}

void	free_env_lines(t_env *env)
{
	t_env	*temp;
	t_env	*next;

	if (!env)
		return ;
	temp = env;
	while (temp)
	{
		next = temp->next;
		del_content(temp);
		temp = next;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 12:43:52 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/22 20:30:43 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	exec_pwd(t_shell *shell, t_prompt *prompt)
{
	(void)prompt;
	ft_printf("%s\n", shell->pwd);
}

void	exec_exit(t_shell *shell, t_prompt *prompt)
{
	free_prompt(prompt);
	free_terminal(shell);
	write(2, "exit\n", 5);
	exit(1);
}

void	builtin_exit(t_shell *shell, t_prompt *prompt)
{
	if (ft_strcmp(prompt->strs[0], "echo") == 0)
		shell->exit_status = 0;
	else if (ft_strcmp(prompt->strs[0], "export") == 0)
		shell->exit_status = 0;
	else if (ft_strcmp(prompt->strs[0], "env") == 0)
		shell->exit_status = 0;
	else if (ft_strcmp(prompt->strs[0], "cd") == 0)
		shell->exit_status = 0;
	else if (ft_strcmp(prompt->strs[0], "pwd") == 0)
		shell->exit_status = 0;
	else if (ft_strcmp(prompt->strs[0], "unset") == 0)
		shell->exit_status = 0;
}

void	execute_builtin(t_shell *shell, t_prompt *prompt)
{
	builtin_exit(shell, prompt);
	if (ft_strcmp(prompt->strs[0], "echo") == 0)
		exec_echo(prompt);
	else if (ft_strcmp(prompt->strs[0], "export") == 0)
		exec_export(shell, prompt);
	else if (ft_strcmp(prompt->strs[0], "env") == 0)
		write_env(prompt, shell->env_lines);
	else if (ft_strcmp(prompt->strs[0], "cd") == 0)
		exec_cd(shell, prompt);
	else if (ft_strcmp(prompt->strs[0], "pwd") == 0)
		exec_pwd(shell, prompt);
	else if (ft_strcmp(prompt->strs[0], "unset") == 0)
		exec_unset(shell, prompt);
	else if (ft_strcmp(prompt->strs[0], "exit") == 0)
		exec_exit(shell, prompt);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 12:43:55 by axbaudri          #+#    #+#             */
/*   Updated: 2025/04/01 00:07:43 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H
# define MAX_ARGS 64
# include <readline/readline.h>
# include <readline/history.h>
# include <string.h>
# include <linux/limits.h>
# include <signal.h>
# include <sys/wait.h>
# include "structures.h"
# include "libft/libft.h"

// Token
void		set_shell_instance(t_shell *shell);
t_shell		*get_shell_instance(void);
void		reset_signals(void);
char		**advanced_tokenize_modified(const char *line);
int			count_raw_cmds(char **raw_cmds);
void		process_default(char c, t_state *state, char **curr);
void		process_in_single(char c, t_state *state, char **curr);
void		process_in_double(char c, t_state *state, char **curr);
void		process_escaping(char c, t_state *state, char **curr);
char		**remove_hd_tokens(char **tokens, char **heredoc);
char		*get_command_path(char *cmd, char **env);
char		**split_pipeline(const char *line);
char		*preprocess_line(const char *line);
char		**build_new_tokens(char **tokens, t_redir **redir, int size);
int			count_non_redir_tokens(char **tokens);
int			invalid_prompt(char	*line);
char		*get_line_without_space(char *line);
char		**prepare_tokens(char **tokens, char **heredoc);

// Redirection
int		contains_redirection(char **tokens);
int		handle_heredoc(const char *delimiter);
void		free_pipeline(t_pipeline *pipeline);
void		execute_pipeline(t_shell *shell, t_pipeline *pipeline, char **env);
int			adv_handle_redirect(const char *target, const char *op, int std_fd);
void		handle_pipe(char *cmd1[], char *cmd2[]);
void		handle_redirection(const char *line, int *i, int *j, char *nw_lin);
int			handle_redirection_char(const char *file, const char *op);
int			redirect_file(const char *target, int std_fd, int flags, int mode);
void		setup_signal(void);
void		handle_sigint(int sig);
void		handle_sigquit(int sig);
char		*expand_variables(const char *input, char **env);
int			apply_redirections(char **token);
int			apply_command_redirections(t_command *cmd);
int			handle_heredoc_parent_pipe(const char *delimiter);
int			process_redirections_loop(char **tokens, int i, int ret);
void		check_signal(int *shlvl);
t_redir		*reverse_redir_list(t_redir *head);

// Outils de strings
pid_t		my_getpid(void);
int			my_setenv(t_env **env, const char *name,
				const char *value, int overwrite);
int			calculate_total_size(int size, char **strs, char *sep);
void		check_error(char *name, char *arg);
int			count_occurs(const char *cmd_line, int to_find);
int			count_quotes(const char *cmd_line);
int			count_strings(char **strs);
int			count_words(const char *str);
char		*ft_strcpy(char *dest, const char *src);
int			ft_strcmp(const char *s1, const char *s2);
char		*ft_strjoin2(int size, char **strs, char *sep);
char		*ft_strndup(const char *src, size_t n);
void		ft_swap(char **s1, char **s2);
int			is_space(int c);
void		sort_strings(char **envp, int size);
int			is_valid_n_option(const char *str);

// Gestion de la structure principale
void		free_2d_array(char **strs);
void		free_terminal(t_shell *shell);
t_shell		*init_shell(char **envp);
char		**get_env_lines(t_env *env);
void		update_vars(t_shell *shell);

// Gestion de l'environnement
char		*get_path_value(char **envp, char *name);
int			get_shell_level(char **envp);
char		*get_command_path(char *cmd, char **env);
char		*get_env_value(char **env, char *key);
char		*search_cmd_in_paths(char **paths, char *cmd);
void		add_env_line(t_env **env, t_env *new);
void		add_lines(t_shell *shell, t_prompt *prompt);
void		copy_env(t_env **env, char **envp);
void		copy_export(t_env **export, char **envp);
int			env_size(t_env *env);
void		exec_cd(t_shell *shell, t_prompt *prompt);
void		exec_export(t_shell *shell, t_prompt *prompt);
void		exec_unset(t_shell *shell, t_prompt *prompt);
void		free_env_lines(t_env *env);
void		free_new_and_temp(t_env *new, t_env *temp);
char		**get_lines_export(char **envp);
char		**get_lines(char **envp);
char		*get_path_value(char **envp, char *name);
int			get_shell_level(char **envp);
int			is_in_list(t_env *env, char *var_name);
t_env		*new_line(char *env_line);
void		remove_line(t_env **lst, char *arg);
char		**split_path(char *env_line);
void		update_line(char *arg, t_env **env);
void		update_paths(t_shell *shell, t_env **env);
void		write_env(t_prompt *prompt, t_env *env);
void		write_export(t_env *env);
void		exec_echo_builtin(t_command *cmd);
char		*do_expand_loop(const char *input, int *i, char *result,
				char **env);
char		*handle_dollar_case(const char *input, int *i, char **env);
char		*expand_var(const char *in, int *i, char **env);
void		check_state(int i, int *state, const char *input);
char		*append_str(char *dest, const char *src);
void		del_content(t_env *temp);

// Parsing du prompt
char		**advanced_tokenize(const char *line);
int			check_path_validity(char *cmd);
int			closed_quotes(char *cmd_line);
void		display_history(t_shell *shell);
void		exec_echo(t_prompt *prompt);
void		execute_builtin(t_shell *shell, t_prompt *prompt);
int			existing_command(char **paths, char *cmd);
void		free_prompt(t_prompt *prompt);
t_prompt	*init_prompt(const char *buffer, char **env);
t_command	*parse_command(char *raw, char **env);
t_pipeline	*parse_input(const char *line, char **env);
int			valid_arg(char *name, char *arg);
int			valid_name(char *name);
int			valid_value(char *s);
void		verif_history(t_shell *shell, const char *input);
int			is_builtin(const char *cmd);
int			process_hd_token(char **tokens, int *i, char **heredoc);
int			count_tokens_without_hd(char **tokens);
char		**build_tokens_without_hd(char **tokens, char **heredoc,
				int new_count);
int			count_non_redir_tokens(char **tokens);
char		**build_tokens_without_redir(char **tokens, int non_redir_count);
char		**build_new_tokens(char **tokens, t_redir **redir, int size);
int			handle_token_build_new_tokens(t_build_ctx *ctx);
t_redir		*create_redirection_token(char **tokens, int *i);
char		*create_redirection_op(char *token);
void		child_execute(t_exec_context *ctx, int i, int prev_fd,
				int pipe_fd[2]);
void		execute_builtin_in_child(t_shell *shell, t_command *cmd,
				char **env);

#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   new_terminal.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/13 15:09:19 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 21:15:57 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_shell	*init_shell(char **envp)
{
	t_shell	*shell;

	shell = (t_shell *)malloc(sizeof(t_shell));
	if (!shell)
		return (NULL);
	shell->env_lines = NULL;
	copy_env(&shell->env_lines, envp);
	shell->export_lines = NULL;
	copy_export(&shell->export_lines, envp);
	shell->env = get_env_lines(shell->env_lines);
	shell->path = get_path_value(shell->env, "PATH");
	shell->home_path = get_path_value(shell->env, "HOME");
	shell->old_pwd = get_path_value(shell->env, "PWD");
	shell->pwd = get_path_value(shell->env, "PWD");
	shell->splitted_path = split_path(shell->path);
	shell->shlvl = get_shell_level(envp);
	shell->history = NULL;
	return (shell);
}

t_prompt	*init_prompt(const char *buffer, char **env)
{
	t_prompt	*prompt;
	char		*expanded;
	char		*preprocessed;

	prompt = malloc(sizeof(t_prompt));
	if (prompt == NULL)
		return (NULL);
	expanded = expand_variables(buffer, env);
	preprocessed = preprocess_line(expanded);
	prompt->cmd_line = ft_strdup(preprocessed);
	prompt->strs = advanced_tokenize(preprocessed);
	prompt->nb_args = count_strings(prompt->strs);
	free(expanded);
	free(preprocessed);
	return (prompt);
}

void	get_mini_env(t_env **env)
{
	t_env	*new;
	char	*pwd_line;
	char	buffer[1000];

	getcwd(buffer, PATH_MAX);
	pwd_line = ft_strjoin("PWD=", buffer);
	new = new_line(pwd_line);
	add_env_line(env, new);
	new = new_line("SHLVL=1");
	add_env_line(env, new);
	new = new_line("_=/usr/bin/env");
	add_env_line(env, new);
}

void	copy_env(t_env **env, char **envp)
{
	t_env	*new;
	int		i;

	i = 0;
	if (!envp[0])
		return (get_mini_env(env));
	while (envp[i])
	{
		new = new_line(envp[i]);
		add_env_line(env, new);
		i++;
	}
}

void	copy_export(t_env **export, char **envp)
{
	t_env	*new;
	int		i;

	i = 0;
	if (!envp[0])
		return (get_mini_env(export));
	sort_strings(envp, count_strings(envp));
	while (envp[i])
	{
		new = new_line(envp[i]);
		add_env_line(export, new);
		i++;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_prompt.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: quenalla <quenalla@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 19:54:44 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/26 18:49:20 by quenalla         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	check_string(int *i, int *count, char c, char *str)
{
	(*i)++;
	(*count)++;
	while (str[*i] && str[*i] != c)
		(*i)++;
	if (str[*i] == c)
		(*count)++;
}

int	closed_quotes(char *cmd_line)
{
	int	i;
	int	quote_count;

	i = 0;
	quote_count = 0;
	while (cmd_line[i])
	{
		if (cmd_line[i] == '\'')
			check_string(&i, &quote_count, '\'', cmd_line);
		else if (cmd_line[i] == '"')
			check_string(&i, &quote_count, '"', cmd_line);
		if (cmd_line[i])
			i++;
	}
	if (quote_count % 2 == 1)
	{
		ft_printf("syntax error: unclosed quote\n");
		return (0);
	}
	return (1);
}

int	valid_arg(char *name, char *arg)
{
	int		i;
	char	*value;

	i = 0;
	if (!(ft_isalpha(name[i]) || name[i] == '_'
			|| name[i] == '$' || name[i] == '<' || name[i] == '>'))
		return (0);
	i++;
	while (name[i] && name[i] != '=')
	{
		if (!(ft_isalnum(name[i]) || name[i] == '_'
				|| name[i] == '$' || name[i] == '<' || name[i] == '>'))
			return (0);
		i++;
	}
	if (count_occurs(arg, '='))
	{
		value = ft_strchr(arg, '=') + 1;
		if (!valid_value(value))
			return (0);
	}
	return (1);
}

int	valid_name(char *name)
{
	int	i;

	i = 0;
	if (!(ft_isalpha(name[i]) || name[i] == '_'
			|| name[i] == '$' || name[i] == '<' || name[i] == '>'))
		return (0);
	i++;
	while (name[i] && name[i] != '=')
	{
		if (!(ft_isalnum(name[i]) || name[i] == '_'
				|| name[i] == '$' || name[i] == '<' || name[i] == '>'))
			return (0);
		i++;
	}
	return (1);
}

int	valid_value(char *s)
{
	int	i;
	int	j;

	i = 0;
	j = ft_strlen(s) - 1;
	if ((s[i] == '\'' && s[j] == '"') || (s[i] == '"' && s[j] == '\''))
		return (0);
	else if ((s[i] == '\'' || s[j] == '\'')
		&& count_occurs(s, '\'') % 2 == 1)
		return (0);
	else if ((s[i] == '"' || s[j] == '\'')
		&& count_occurs(s, '"') % 2 == 1)
		return (0);
	return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/22 21:21:15 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/30 15:08:12 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_raw_cmds(char **raw_cmds)
{
	int	count;

	count = 0;
	while (raw_cmds[count])
		count++;
	return (count);
}

char	**remove_redirection_tokens(char **tokens)
{
	int		non_redir_count;
	char	**new_tokens;

	non_redir_count = count_non_redir_tokens(tokens);
	if (non_redir_count == -1)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		free_2d_array(tokens);
		return (NULL);
	}
	new_tokens = build_tokens_without_redir(tokens, non_redir_count);
	free_2d_array(tokens);
	return (new_tokens);
}

char	**remove_hd_tokens(char **tokens, char **heredoc)
{
	int		new_count;
	char	**new_tokens;

	if (tokens == NULL)
		return (NULL);
	new_count = count_tokens_without_hd(tokens);
	if (new_count == -1)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		free_2d_array(tokens);
		return (NULL);
	}
	new_tokens = build_tokens_without_hd(tokens, heredoc, new_count);
	free_2d_array(tokens);
	return (new_tokens);
}

static char	**extract_redirections(char **tokens, t_redir **redir)
{
	int		non_redir_count;
	char	**new_tokens;

	non_redir_count = count_non_redir_tokens(tokens);
	if (non_redir_count == -1)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		free_2d_array(tokens);
		return (NULL);
	}
	new_tokens = build_new_tokens(tokens, redir, non_redir_count);
	free_2d_array(tokens);
	return (new_tokens);
}

t_command	*parse_command(char *raw, char **env)
{
	t_command	*cmd;
	char		*expanded_raw;
	char		**tokens;
	char		*heredoc;

	cmd = malloc(sizeof(t_command));
	if (cmd == NULL)
		return (NULL);
	expanded_raw = expand_variables(raw, env);
	tokens = advanced_tokenize_modified(expanded_raw);
	free(expanded_raw);
	heredoc = NULL;
	tokens = prepare_tokens(tokens, &heredoc);
	cmd->heredoc_delim = heredoc;
	cmd->heredoc_fd = -1;
	cmd->redirections = NULL;
	tokens = extract_redirections(tokens, &cmd->redirections);
	if (tokens == NULL)
		return (free(cmd), NULL);
	cmd->args = tokens;
	return (cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/22 21:21:24 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/30 15:09:08 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**prepare_tokens(char **tokens, char **heredoc)
{
	tokens = remove_hd_tokens(tokens, heredoc);
	if (tokens == NULL || tokens[0] == NULL)
	{
		tokens = malloc(sizeof(char *) * 2);
		if (!tokens)
			return (NULL);
		tokens[0] = ft_strdup("");
		tokens[1] = NULL;
	}
	return (tokens);
}

static int	fill_pipeline(t_pipeline *pipeline, char **raw_cmds, int count,
				char **env)
{
	int			i;
	t_command	*cmd;

	i = 0;
	while (i < count)
	{
		cmd = parse_command(raw_cmds[i], env);
		if (!cmd)
			return (0);
		pipeline->commands[i] = *cmd;
		free(cmd);
		i++;
	}
	return (1);
}

t_pipeline	*parse_input(const char *line, char **env)
{
	t_pipeline	*pipeline;
	char		**raw_cmds;
	int			count;
	int			i;

	raw_cmds = split_pipeline(line);
	if (!raw_cmds)
		return (NULL);
	count = count_raw_cmds(raw_cmds);
	pipeline = malloc(sizeof(t_pipeline));
	if (!pipeline)
		return (free_2d_array(raw_cmds), NULL);
	pipeline->count = count;
	pipeline->commands = malloc(sizeof(t_command) * count);
	if (!pipeline->commands)
		return (free(pipeline), free_2d_array(raw_cmds), NULL);
	if (!fill_pipeline(pipeline, raw_cmds, count, env))
		return (free_2d_array(raw_cmds),
			free(pipeline->commands), free(pipeline), NULL);
	i = -1;
	while (raw_cmds[++i])
		free(raw_cmds[i]);
	return (free(raw_cmds), pipeline);
}

int	count_non_redir_tokens(char **tokens)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (tokens[i])
	{
		if (ft_strcmp(tokens[i], ">") == 0
			|| ft_strcmp(tokens[i], ">>") == 0
			|| ft_strcmp(tokens[i], "<") == 0)
		{
			if (!tokens[i + 1])
				return (-1);
			i = i + 2;
		}
		else
		{
			count++;
			i++;
		}
	}
	return (count);
}

char	**build_tokens_without_redir(char **tokens, int non_redir_count)
{
	int		i;
	int		count;
	char	**new_tokens;

	new_tokens = malloc(sizeof(char *) * (non_redir_count + 1));
	if (!new_tokens)
		return (NULL);
	i = 0;
	count = 0;
	while (tokens[i])
	{
		if (ft_strcmp(tokens[i], ">") == 0
			|| ft_strcmp(tokens[i], ">>") == 0
			|| ft_strcmp(tokens[i], "<") == 0)
			i = i + 2;
		else
		{
			new_tokens[count++] = ft_strdup(tokens[i]);
			i++;
		}
	}
	new_tokens[count] = NULL;
	return (new_tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 13:22:16 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 18:23:58 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*create_redirection_op(char *token)
{
	return (ft_strtrim(token, " \t"));
}

t_redir	*create_redirection_token(char **tokens, int *i)
{
	char	*temp;
	t_redir	*new_redir;

	temp = ft_strtrim(tokens[*i + 1], " \t");
	if (!temp)
		return (NULL);
	if (temp[0] == '\0')
		return (free(temp), NULL);
	new_redir = malloc(sizeof(t_redir));
	if (!new_redir)
		return (free(temp), NULL);
	new_redir->op = create_redirection_op(tokens[*i]);
	if (!new_redir->op)
	{
		free(new_redir);
		free(temp);
		return (NULL);
	}
	new_redir->target = ft_strdup(temp);
	free(temp);
	new_redir->next = NULL;
	*i = *i + 2;
	return (new_redir);
}

int	count_tokens_without_hd(char **tokens)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (tokens[i])
	{
		if (ft_strcmp(tokens[i], "<<") == 0)
		{
			if (tokens[i + 1] == NULL)
				return (-1);
			i = i + 2;
		}
		else
		{
			count++;
			i++;
		}
	}
	return (count);
}

int	process_hd_token(char **tokens, int *i, char **heredoc)
{
	if (tokens[*i + 1] == NULL)
	{
		ft_printf("bash: unexpected error: missing heredoc delimiter\n");
		return (-1);
	}
	*heredoc = ft_strdup(tokens[*i + 1]);
	*i = *i + 2;
	return (0);
}

char	**build_tokens_without_hd(char **tokens, char **heredoc, int new_count)
{
	int		i;
	int		j;
	char	**new_tokens;

	i = 0;
	j = 0;
	new_tokens = malloc(sizeof(char *) * (new_count + 1));
	if (new_tokens == NULL)
		return (NULL);
	while (tokens[i])
	{
		if (ft_strcmp(tokens[i], "<<") == 0)
		{
			if (process_hd_token(tokens, &i, heredoc) == -1)
			{
				free_2d_array(new_tokens);
				return (NULL);
			}
		}
		else
			new_tokens[j++] = ft_strdup(tokens[i++]);
	}
	new_tokens[j] = NULL;
	return (new_tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/17 03:16:43 by qacjl             #+#    #+#             */
/*   Updated: 2025/04/01 00:15:35 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	create_pipe_block(int i, int cmd_count, int pipe_fd[2])
{
	if (i < cmd_count - 1)
	{
		if (pipe(pipe_fd) == -1)
		{
			perror("pipe");
			exit(EXIT_FAILURE);
		}
	}
	else
	{
		pipe_fd[0] = -1;
		pipe_fd[1] = -1;
	}
}

int	handle_fork_and_update(int i, int prev_fd, int pipe_fd[2],
			t_exec_context *ctx)
{
	pid_t	pid;
	int		new_prev_fd;

	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	}
	if (pid == 0)
		child_execute(ctx, i, prev_fd, pipe_fd);
	if (prev_fd != -1)
		close(prev_fd);
	if (i < ctx->cmd_count - 1)
	{
		new_prev_fd = pipe_fd[0];
		close(pipe_fd[1]);
	}
	else
		new_prev_fd = -1;
	waitpid(pid, NULL, 0);
	return (new_prev_fd);
}

static t_exec_context	init_ctx(t_shell *shell, t_pipeline *pipeline,
							char **env)
{
	t_exec_context	ctx;

	ctx.pipeline = pipeline;
	ctx.env = env;
	ctx.cmd_count = pipeline->count;
	ctx.shell = shell;
	return (ctx);
}

/*static void	handle_single_cat(t_pipeline *pipeline, char **env)
{
	pid_t	pid;
	char	*path;

	pid = fork();
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		path = get_command_path(pipeline->commands[0].args[0], env);
		if (path == NULL)
		{
			perror("cat not found");
			exit(EXIT_FAILURE);
		}
		execve(path, pipeline->commands[0].args, env);
		perror("execve");
		exit(EXIT_FAILURE);
	}
	waitpid(pid, NULL, 0);
}*/

static pid_t	run_pipeline_command(t_exec_context *ctx, int i, int *prev_fd)
{
	int		pipe_fd[2];
	pid_t	pid;

	create_pipe_block(i, ctx->cmd_count, pipe_fd);
	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	}
	if (pid == 0)
		child_execute(ctx, i, *prev_fd, pipe_fd);
	if (*prev_fd != -1)
		close(*prev_fd);
	if (i < ctx->cmd_count - 1)
	{
		*prev_fd = pipe_fd[0];
		close(pipe_fd[1]);
	}
	else
		*prev_fd = -1;
	return (pid);
}

void	execute_pipeline(t_shell *shell, t_pipeline *pipeline, char **env)
{
	int				i;
	int				prev_fd;
	t_exec_context	ctx;
	pid_t			last_pid;

	i = 0;
	prev_fd = -1;
	ctx = init_ctx(shell, pipeline, env);
	while (i < ctx.cmd_count)
	{
		last_pid = run_pipeline_command(&ctx, i, &prev_fd);
		i++;
	}
	if (prev_fd != -1)
		close(prev_fd);
	waitpid(last_pid, &shell->exit_status, 0);
	if (WIFEXITED(shell->exit_status))
		shell->exit_status = WEXITSTATUS(shell->exit_status);
	else if (WIFSIGNALED(shell->exit_status))
		shell->exit_status = 128 + WTERMSIG(shell->exit_status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 14:02:36 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/31 16:56:10 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	execute_env_builtin(t_shell *shell)
{
	t_env	*temp;

	temp = shell->env_lines;
	while (temp)
	{
		if (temp->value)
			ft_printf("%s=%s\n", temp->name, temp->value);
		temp = temp->next;
	}
}

static void	process_builtin(t_shell *shell, t_command *cmd)
{
	if (ft_strcmp(cmd->args[0], "echo") == 0)
		exec_echo_builtin(cmd);
	else if (ft_strcmp(cmd->args[0], "export") == 0)
	{
		if (cmd->args[1] == NULL)
			write_export(shell->export_lines);
	}
	else if (ft_strcmp(cmd->args[0], "env") == 0)
		execute_env_builtin(shell);
	else if (ft_strcmp(cmd->args[0], "cd") == 0)
		ft_printf("cd: modification de l'env impossible dans un pipe\n");
	else if (ft_strcmp(cmd->args[0], "pwd") == 0)
		ft_printf("%s\n", shell->pwd);
	else if (ft_strcmp(cmd->args[0], "unset") == 0)
		ft_printf("unset: modification de l'env impossible dans un pipe\n");
	else if (ft_strcmp(cmd->args[0], "exit") == 0)
		exit(0);
	else if (ft_strcmp(cmd->args[0], "history") == 0)
		display_history(shell);
	else
		ft_printf("Builtin %s non supporté en pipeline\n", cmd->args[0]);
}

void	execute_builtin_in_child(t_shell *shell, t_command *cmd, char **env)
{
	(void)env;
	process_builtin(shell, cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline3.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 14:05:14 by qacjl             #+#    #+#             */
/*   Updated: 2025/04/01 00:14:13 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	setup_child_io(int i, int prev_fd, int pipe_fd[2],
		t_exec_context *ctx)
{
	if (i != 0)
	{
		dup2(prev_fd, STDIN_FILENO);
		close(prev_fd);
	}
	if (i < ctx->cmd_count - 1)
	{
		dup2(pipe_fd[1], STDOUT_FILENO);
		close(pipe_fd[0]);
		close(pipe_fd[1]);
	}
}

/*static void	handle_heredoc_and_cat(t_command *cmd)
{
	int	hd_fd;

	if (cmd->heredoc_fd != -1)
	{
		hd_fd = cmd->heredoc_fd;
		if (dup2(hd_fd, STDIN_FILENO) == -1)
		{
			perror("dup2 heredoc");
			exit(EXIT_FAILURE);
		}
		close(hd_fd);
	}
}*/

static void	run_external_command(t_exec_context *ctx, t_command *cmd)
{
	char	*path;

	path = get_command_path(cmd->args[0], ctx->env);
	if (!path)
	{
		ft_printf("minishell: %s: command not found\n", cmd->args[0]);
		ctx->shell->exit_status = 127;
		exit(127);
	}
	if (execve(path, cmd->args, ctx->env) == -1)
	{
		perror("minishell");
		ctx->shell->exit_status = 126;
		exit(126);
	}
	free(path);
	perror("execve");
	exit(EXIT_FAILURE);
}

static void	handle_child_command(t_exec_context *ctx, t_command *cmd)
{
	if (apply_command_redirections(cmd) == -1)
		exit(EXIT_FAILURE);
	if (cmd->args[0] == NULL || cmd->args[0][0] == '\0')
		exit(0);
	if (is_builtin(cmd->args[0]))
	{
		execute_builtin_in_child(ctx->shell, cmd, ctx->env);
		exit(0);
	}
	run_external_command(ctx, cmd);
}

void	child_execute(t_exec_context *ctx, int i, int prev_fd, int pipe_fd[2])
{
	t_command	*cmd;

	cmd = &ctx->pipeline->commands[i];
	setup_child_io(i, prev_fd, pipe_fd, ctx);
	if (cmd->heredoc_fd != -1)
	{
		if (dup2(cmd->heredoc_fd, STDIN_FILENO) == -1)
		{
			perror("dup2 heredoc");
			exit(EXIT_FAILURE);
		}
		close(cmd->heredoc_fd);
	}
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
	handle_child_command(ctx, cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   read_content.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 16:43:09 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 20:16:01 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_strings(char **strs)
{
	int	i;

	i = 0;
	while (strs[i])
		i++;
	return (i);
}

char	**get_lines(char **envp)
{
	int		i;
	int		size;
	char	**lines;

	i = 0;
	size = count_strings(envp);
	lines = (char **)malloc(sizeof(char *) * (size + 1));
	if (!lines)
		return (NULL);
	while (i < size)
	{
		lines[i] = ft_strdup(envp[i]);
		i++;
	}
	lines[i] = NULL;
	return (lines);
}

char	**get_env_lines(t_env *env)
{
	t_env	*temp;
	int		i;
	char	**new_lines;

	i = 0;
	new_lines = (char **)malloc(sizeof(char *) * (env_size(env) + 1));
	if (!new_lines || !env)
		return (NULL);
	temp = env;
	while (temp)
	{
		new_lines[i] = ft_strdup(temp->line);
		temp = temp->next;
		i++;
	}
	new_lines[i] = 0;
	return (new_lines);
}

int	count_occurs(const char *cmd_line, int to_find)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (cmd_line[i])
	{
		if (cmd_line[i] == to_find)
			count++;
		i++;
	}
	return (count);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect_file.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/17 02:42:33 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/28 11:49:22 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	redirect_file(const char *target, int std_fd, int flags, int mode)
{
	int	fd;

	fd = open(target, flags, mode);
	if (fd < 0)
	{
		perror("open");
		return (-1);
	}
	if (dup2(fd, std_fd) == -1)
	{
		perror("dup2");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

int	apply_redirections(char **tokens)
{
	int	i;
	int	ret;

	i = 0;
	ret = 0;
	return (process_redirections_loop(tokens, i, ret));
}

int	apply_command_redirections(t_command *cmd)
{
	t_redir	*redir;
	int		ret;

	redir = reverse_redir_list(cmd->redirections);
	ret = 0;
	while (redir)
	{
		if (ft_strcmp(redir->op, ">") == 0)
			ret = redirect_file(redir->target, STDOUT_FILENO,
					O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (ft_strcmp(redir->op, ">>") == 0)
			ret = redirect_file(redir->target, STDOUT_FILENO,
					O_WRONLY | O_CREAT | O_APPEND, 0644);
		else if (ft_strcmp(redir->op, "<") == 0)
			ret = redirect_file(redir->target, STDIN_FILENO, O_RDONLY, 0);
		if (ret == -1)
			return (-1);
		redir = redir->next;
	}
	return (0);
}

static void	free_redirections(t_redir *redir)
{
	t_redir	*tmp;

	while (redir)
	{
		tmp = redir->next;
		free(redir->op);
		free(redir->target);
		free(redir);
		redir = tmp;
	}
}

void	free_pipeline(t_pipeline *pipeline)
{
	int	i;
	int	j;

	if (pipeline == NULL)
		return ;
	i = 0;
	while (i < pipeline->count)
	{
		if (pipeline->commands[i].args)
		{
			j = 0;
			while (pipeline->commands[i].args[j])
				free(pipeline->commands[i].args[j++]);
			free(pipeline->commands[i].args);
		}
		if (pipeline->commands[i].heredoc_delim)
			free(pipeline->commands[i].heredoc_delim);
		if (pipeline->commands[i].redirections)
			free_redirections(pipeline->commands[i].redirections);
		i++;
	}
	free(pipeline->commands);
	free(pipeline);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect_file2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 10:56:26 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/28 11:33:16 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_redir	*reverse_redir_list(t_redir *head)
{
	t_redir	*prev;
	t_redir	*curr;
	t_redir	*next;

	prev = NULL;
	curr = head;
	while (curr)
	{
		next = curr->next;
		curr->next = prev;
		prev = curr;
		curr = next;
	}
	return (prev);
}

int	process_output_redirect(char **tokens, int *index)
{
	int	fd;

	if (tokens[*index + 1] == 0)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		return (-1);
	}
	fd = open(tokens[*index + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
	{
		perror("open");
		return (-1);
	}
	dup2(fd, STDOUT_FILENO);
	close(fd);
	*index = *index + 2;
	return (0);
}

int	process_input_redirect(char **tokens, int *index)
{
	int	fd;

	if (tokens[*index + 1] == 0)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		return (-1);
	}
	fd = open(tokens[*index + 1], O_RDONLY);
	if (fd < 0)
	{
		perror("open");
		return (-1);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
	*index = *index + 2;
	return (0);
}

int	process_append_redirect(char **tokens, int *index)
{
	int	fd;

	if (tokens[*index + 1] == 0)
	{
		ft_printf("bash: syntax error near unexpected token `newline'\n");
		return (-1);
	}
	fd = open(tokens[*index + 1], O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd < 0)
	{
		perror("open");
		return (-1);
	}
	dup2(fd, STDOUT_FILENO);
	close(fd);
	*index = *index + 2;
	return (0);
}

int	process_redirections_loop(char **tokens, int i, int ret)
{
	while (tokens[i])
	{
		if (ft_strcmp(tokens[i], ">") == 0)
		{
			ret = process_output_redirect(tokens, &i);
			if (ret < 0)
				return (-1);
		}
		else if (ft_strcmp(tokens[i], ">>") == 0)
		{
			ret = process_append_redirect(tokens, &i);
			if (ret < 0)
				return (-1);
		}
		else if (ft_strcmp(tokens[i], "<") == 0)
		{
			ret = process_input_redirect(tokens, &i);
			if (ret < 0)
				return (-1);
		}
		else
			i = i + 1;
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_instance.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 16:40:20 by qacjl             #+#    #+#             */
/*   Updated: 2025/04/01 00:10:49 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_shell *g_shell_instance = NULL;

void set_shell_instance(t_shell *shell)
{
    g_shell_instance = shell;
}

t_shell *get_shell_instance(void)
{
    return (g_shell_instance);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/09 16:16:58 by qacjl             #+#    #+#             */
/*   Updated: 2025/04/01 00:15:09 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_sigint(int sig)
{
	(void)sig;
	write(1, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
	get_shell_instance()->exit_status = 130;
}

void	setup_signal(void)
{
	signal(SIGINT, handle_sigint);
	signal(SIGQUIT, SIG_IGN);
}

void	reset_signals(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}

void	check_signal(int *shlvl)
{
	if (*shlvl <= 1)
		setup_signal();
	else
		signal(SIGINT, SIG_DFL);
}

int	is_builtin(const char *cmd)
{
	if (ft_strcmp(cmd, "cd") == 0)
		return (1);
	if (ft_strcmp(cmd, "echo") == 0)
		return (1);
	if (ft_strcmp(cmd, "export") == 0)
		return (1);
	if (ft_strcmp(cmd, "env") == 0)
		return (1);
	if (ft_strcmp(cmd, "unset") == 0)
		return (1);
	if (ft_strcmp(cmd, "pwd") == 0)
		return (1);
	if (ft_strcmp(cmd, "exit") == 0)
		return (1);
	if (ft_strcmp(cmd, "history") == 0)
		return (1);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split_pipeline.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/21 00:11:01 by qacjl             #+#    #+#             */
/*   Updated: 2025/03/27 11:34:54 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	update_quote_state(int *state, char c)
{
	if (c == '\'' && *state != 2)
	{
		if (*state == 1)
			*state = 0;
		else
			*state = 1;
	}
	else if (c == '\"' && *state != 1)
	{
		if (*state == 2)
			*state = 0;
		else
			*state = 2;
	}
}

int	count_segments(const char *line)
{
	int	i;
	int	state;
	int	count;

	i = 0;
	state = 0;
	count = 0;
	while (line[i])
	{
		update_quote_state(&state, line[i]);
		if (line[i] == '|' && state == 0)
			count++;
		i = i + 1;
	}
	return (count);
}

void	fill_segments(const char *line, char **segments)
{
	int	i;
	int	start;
	int	state;
	int	seg_index;

	i = 0;
	start = 0;
	state = 0;
	seg_index = 0;
	while (line[i])
	{
		update_quote_state(&state, line[i]);
		if (line[i] == '|' && state == 0)
		{
			segments[seg_index] = ft_strndup(line + start, i - start);
			seg_index = seg_index + 1;
			start = i + 1;
		}
		i = i + 1;
	}
	segments[seg_index] = ft_strdup(line + start);
	segments[seg_index + 1] = NULL;
}

char	**split_pipeline(const char *line)
{
	int		count;
	char	**segments;

	count = count_segments(line);
	segments = malloc(sizeof(char *) * (count + 2));
	if (segments == NULL)
		return (NULL);
	fill_segments(line, segments);
	return (segments);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   string_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: axbaudri <axbaudri@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/07 11:41:53 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/30 21:11:14 by axbaudri         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i])
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = 0;
	return (dest);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	int	i;

	i = 0;
	while (s1[i] && s1[i] == s2[i])
		i++;
	return (s1[i] - s2[i]);
}

int	count_words(const char *str)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	if (str[0] != 0 && !is_space(str[0]))
	{
		i++;
		count++;
	}
	while (str[i])
	{
		if (is_space(str[i]) && (str[i + 1] != 0 && !is_space(str[i + 1])))
			count++;
		i++;
	}
	return (count);
}

char	*ft_strndup(const char *src, size_t n)
{
	size_t	i;
	char	*dest;

	i = 0;
	dest = (char *)malloc(sizeof(char) * (n + 1));
	if (!dest)
		return (NULL);
	while (src[i] && i < n)
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = 0;
	return (dest);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   structures.h                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/27 14:22:37 by axbaudri          #+#    #+#             */
/*   Updated: 2025/04/01 00:15:57 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef STRUCTURES_H
# define STRUCTURES_H
# include "libft/libft.h"

typedef struct s_redir
{
	char			*op;
	char			*target;
	struct s_redir	*next;
}	t_redir;

typedef struct s_build_ctx
{
	char		**tokens;
	int			i;
	int			j;
	char		**new_tokens;
	t_redir		**redir;
}	t_build_ctx;

typedef struct s_command
{
	char		**args;
	char		*heredoc_delim;
	int			heredoc_fd;
	t_redir		*redirections;
}	t_command;

typedef struct s_pipeline
{
	t_command	*commands;
	int			count;
}	t_pipeline;

typedef struct s_env
{
	char			*name;
	char			*value;
	char			*line;
	struct s_env	*next;
}	t_env;

typedef struct s_shell
{
	int		shlvl;
	char	*path;
	char	*home_path;
	char	*pwd;
	char	*old_pwd;
	char	**splitted_path;
	char	**env;
	t_env	*env_lines;
	t_env	*export_lines;
	t_list	*history;
	int		exit_status;
}	t_shell;

typedef struct s_exec_context
{
	t_pipeline	*pipeline;
	char		**env;
	int			cmd_count;
	t_shell		*shell;
}	t_exec_context;

typedef struct s_prompt
{
	char	*cmd_line;
	char	*echo;
	char	**strs;
	int		nb_args;
}	t_prompt;

typedef enum e_state
{
	STATE_DEFAULT,
	STATE_IN_SINGLE,
	STATE_IN_DOUBLE,
	STATE_ESCAPING
}				t_state;

typedef struct s_tokenize_context
{
	int		i;
	int		ti;
	char	**tokens;
	char	*curr;
	t_state	state;
}	t_tokenize_context;

#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   write_content.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: qacjl <qacjl@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/13 17:10:48 by axbaudri          #+#    #+#             */
/*   Updated: 2025/03/27 07:01:26 by qacjl            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	write_env(t_prompt *prompt, t_env *env)
{
	t_env	*temp;

	temp = env;
	if (prompt->nb_args != 1)
		ft_printf("env: '%s': No such file or directory\n", prompt->strs[1]);
	else
	{
		while (temp)
		{
			if (temp->value)
				ft_printf("%s=%s\n", temp->name, temp->value);
			temp = temp->next;
		}
	}
}

void	write_export(t_env *env)
{
	t_env	*temp;

	temp = env;
	while (temp)
	{
		if (temp->value)
			ft_printf("declare -x %s=\"%s\"\n", temp->name, temp->value);
		else
			ft_printf("declare -x %s=\"\"\n", temp->name);
		temp = temp->next;
	}
}

int	calculate_total_size(int size, char **strs, char *sep)
{
	int	i;
	int	total_size;

	i = 0;
	total_size = 0;
	while (i < size)
	{
		total_size += ft_strlen(strs[i]);
		if (i < size - 1)
			total_size += ft_strlen(sep);
		i++;
	}
	return (total_size);
}

char	*ft_strjoin2(int size, char **strs, char *sep)
{
	int		i;
	int		j;
	int		total_size;
	char	*new_string;

	i = 0;
	j = 0;
	total_size = calculate_total_size(size, strs, sep);
	new_string = (char *)malloc(sizeof(char) * total_size + 1);
	if (!new_string)
		return (NULL);
	while (i < size)
	{
		ft_strcpy(new_string + j, strs[i]);
		j += ft_strlen(strs[i]);
		if (i < size - 1)
		{
			ft_strcpy(new_string + j, sep);
			j += ft_strlen(sep);
		}
		i++;
	}
	new_string[total_size] = 0;
	return (new_string);
}

char	*get_line_without_space(char *line)
{
	int		i;
	int		j;
	int		size;
	char	*new_string;

	i = 0;
	size = 0;
	while (line[i])
		if (!is_space(line[i++]))
			size++;
	new_string = (char *)malloc(sizeof(char) * (size + 1));
	if (!new_string)
		return (NULL);
	i = 0;
	j = 0;
	while (line[i])
	{
		if (!is_space(line[i]))
			new_string[j++] = line[i];
		i++;
	}
	new_string[j] = 0;
	return (new_string);
}


libft :


/ft_atoi.c
/ft_bzero.c
/ft_calloc.c
/ft_isalnum.c
/ft_isalpha.c
/ft_isascii.c
/ft_isdigit.c
/ft_isprint.c
/ft_itoa.c
/ft_lstadd_back.c
/ft_lstadd_front.c
/ft_lstclear.c
/ft_lstdelone.c
/ft_lstiter.c
/ft_lstlast.c
/ft_lstnew.c
/ft_lstsize.c
/ft_memchr.c
/ft_memcmp.c
/ft_memcpy.c
/ft_memmove.c
/ft_memset.c
/ft_printf.c
/ft_putchar.c
/ft_putchar_fd.c
/ft_putendl_fd.c
/ft_putnbr.c
/ft_putnbr_base_long.c
/ft_putnbr_base_lower.c
/ft_putnbr_base_upper.c
/ft_putnbr_fd.c
/ft_putnbr_unsigned.c
/ft_putstr.c
/ft_putstr_fd.c
/ft_split.c
/ft_strchr.c
/ft_strdup.c
/ft_striteri.c
/ft_strjoin.c
/ft_strlcat.c
/ft_strlcpy.c
/ft_strlen.c
/ft_strmapi.c
/ft_strncmp.c
/ft_strnstr.c
/ft_strrchr.c
/ft_strtrim.c
/ft_substr.c
/ft_tolower.c
/ft_toupper.c
/ft_write_address.c
/get_next_line.c


Les SEULES fonction externe autorisé :

readline, rl_clear_history, rl_on_new_line,
rl_replace_line, rl_redisplay, add_history,
printf, malloc, free, write, access, open, read,
close, fork, wait, waitpid, wait3, wait4, signal,
sigaction, sigemptyset, sigaddset, kill, exit,
getcwd, chdir, stat, lstat, fstat, unlink, execve,
dup, dup2, pipe, opendir, readdir, closedir,
strerror, perror, isatty, ttyname, ttyslot, ioctl,
getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
tgetnum, tgetstr, tgoto, tputs

